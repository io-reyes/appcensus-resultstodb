import csv
import argparse
import ConfigParser
import logging
import os
import calendar
import datetime

from dbops import dbops

def _parse_args():
    parser = argparse.ArgumentParser(description='Put parsed AppCensus test results into the database')
    parser.add_argument('dbcreds', help='Path to a file containing database connection details and credentials')
    parser.add_argument('--packetfile', help='Path to the file generated by the Reardon Packet Parser')
    parser.add_argument('--packetfolder', help='Path to a folder containing extracted packets from the Reardon Packet Parser')
    parser.add_argument('--permfile', help='Path to the file generated by the Reardon Permission Parser')
    parser.add_argument('--test', action='store_true', help='Do not push to DB')
    parser.add_argument('--verbose', '-v', action='store_true', help='Display verbose logging')

    return parser.parse_args()

def _parse_creds(creds_file):
    config = ConfigParser.ConfigParser()
    config.read(creds_file)

    # Get the database login
    database_header = 'Database'
    db_cred = None
    if database_header in config.sections():
        db_cred = {'host':config.get(database_header, 'host'), \
                   'database':config.get(database_header, 'database'), \
                   'user':config.get(database_header, 'user'), \
                   'password':config.get(database_header, 'password')}
        logging.info('Found database credentials for host=%s, database=%s, user=%s' % (db_cred['host'], db_cred['database'], db_cred['user']))

    return db_cred

def _enable_verbose():
    logging.basicConfig(level=logging.DEBUG)
    logging.info('Enabled INFO level verbose logging')

def _init_db(creds_file):
    db_creds = _parse_creds(creds_file)
    dbops.init(db_creds['host'], db_creds['database'], db_creds['user'], db_creds['password'])

    logging.info('Connected to DB host %s database %s as user %s' % (db_creds['host'], db_creds['database'], db_creds['user']))

def _log_date_to_timestamp(log_date):
    # Example: 06-06 15:39:47.707

    # If the month-day is in the future, assume the previous year, otherwise assume the current year
    current = datetime.datetime.utcnow()
    parsed = datetime.datetime.strptime(log_date, '%m-%d %H:%M:%S.%f')
    parsed = parsed.replace(year=current.year, tzinfo=current.tzinfo)

    if(parsed > current):
        parsed = parsed.replace(year=current.year - 1)

    logging.info('Parsed %s as datetime %s' % (log_date, str(parsed)))

    # Convert to seconds from epoch
    timestamp = calendar.timegm(parsed.utctimetuple())

    logging.info('Parsed %s as timestamp %d from epoch' % (log_date, timestamp))

    return timestamp

_last_package = None
_last_version = None
_last_release_id = None
def _get_release_id(package_name, version_code):
    global _last_package, _last_version, _last_release_id

    if(package_name != _last_package or version_code != _last_version):
        _last_package = package_name
        _last_version = version_code
        release_id = dbops.get_release_id(package_name, version_code)

        assert release_id is not None, 'App-version %s-%d was not found in the database' % (package_name, version_code)
        _last_release_id = release_id
        logging.info('For app/version %s-%d, found release ID %d in DB' % (package_name, version_code, _last_release_id))

    return _last_release_id

def _read_packet_file(packet_hash, packet_folder):
    if(packet_folder is not None):
        packet = os.path.join(packet_folder, packet_hash)

        try:
            with open(packet, 'r') as f:
                return f.read().decode('utf-8')
        except:
            pass

    return None

def read_packets(packet_file, packet_folder=None, test=False):
    assert os.path.isfile(packet_file), 'Input packet file %s does not exist' % packet_file
    EXPECTED_COLUMNS = 12

    processed_releases = set()

    with open(packet_file, 'r') as fh:
        reader = csv.reader(fh)
        for row in reader:
            # com.powerful.cleaner , 9 , track.appsflyer.com , track.appsflyer.com , 52.214.17.131 , 443 , 1 , androidid , 688 , 4BAFEDF916017D165B040C38F3A11E89D4FDB579 , 517ABCF2490089CA953563C12BEBE4546CED831A , 06-09 03:44:51.854

            assert len(row) == EXPECTED_COLUMNS, 'Expected %d columns, got %d (%s)' % (EXPECTED_COLUMNS, len(row), str(row))

            try: 
                package_name = row[0]
                version_code = int(row[1])
                domain = row[2]
                tls_sni = row[3]
                ip_address = row[4]
                port = int(row[5])
                is_tls = int(row[6])
                data_type = row[7]
                match_position = int(row[8])
                payload = _read_packet_file(row[9], packet_folder)
                decoded_hash = row[10]
                timestamp = _log_date_to_timestamp(row[11])

                logging.debug('package_name=%s, version_code=%d, domain=%s, tls_sni=%s, ip_address=%s, port=%d, is_tls=%d, data_type=%s, payload=%s, timestamp=%d' % \
                              (package_name, version_code, domain, tls_sni, ip_address, port, is_tls, data_type, payload, timestamp))

                release_id = _get_release_id(package_name, version_code)

                if(not test):
                    dbops.insert_transmission(release_id, data_type, timestamp, \
                                              domain=domain, tls_sni=tls_sni, ip_address=ip_address, port=port, is_tls=is_tls, payload=payload)
                    processed_releases.add(release_id)
            except ValueError as e:
                logging.error('ValueError for row %s, skipping' % str(row))
                logging.exception(e)

                continue

    return processed_releases

def read_perms(perms_file, test=False):
    assert os.path.isfile(perms_file), 'Input permissions file %s does not exist' % perms_file
    EXPECTED_COLUMNS = 5

    processed_releases = set()

    with open(perms_file, 'r') as fh:
        reader = csv.reader(fh)
        for row in reader:
            # com.yelp.android,19013603,WRITE_EXTERNAL_STORAGE,0,0
            # com.yelp.android,19013603,GET_ACCOUNTS,1,06-08 18:42:39.285
            assert len(row) == EXPECTED_COLUMNS, 'Expected %d columns, got %d (%s)' % (EXPECTED_COLUMNS, len(row), str(row))

            try:
                package_name = row[0]
                version_code = int(row[1])
                permission = row[2]
                is_used = int(row[3])
                timestamp = _log_date_to_timestamp(row[4]) if is_used == 1 else 0

                logging.debug('package_name=%s, version_code=%d, permission=%s' % (package_name, version_code, permission))

                release_id = _get_release_id(package_name, version_code)

                if(not test):
                    dbops.insert_permission(release_id, permission, timestamp, is_used=is_used)
                    processed_releases.add(release_id)
            except ValueError as e:
                logging.error('ValueError for row %s, skipping' % str(row))
                logging.exception(e)

                continue

    return processed_releases

def mark_as_tested(release_ids, test=False):
    if(not test):
        for release_id in release_ids:
            dbops.update_release_tested(release_id)

if __name__ == '__main__':
    args = _parse_args()

    if(args.verbose):
        _enable_verbose()

    _init_db(args.dbcreds)

    processed_ids = set()

    packet_file = args.packetfile
    if(packet_file is not None):
        processed = read_packets(packet_file, packet_folder=args.packetfolder, test=args.test)
        processed_ids.update(processed)
    
    perm_file = args.permfile
    if(perm_file is not None):
        processed = read_perms(perm_file, test=args.test)
        processed_ids.update(processed)

    mark_as_tested(processed_ids, test=args.test)

